<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="https://fav.farm/ğŸ„" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Interactive Jewel Christmas Tree" />
    <title>Jewel Christmas Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        margin: 0;
        background-color: #000;
        overflow: hidden;
        touch-action: none;
      }
      canvas {
        display: block;
      }
      .mirror { transform: scaleX(-1); }
      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
    </style>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.3.1",
    "react/": "https://esm.sh/react@18.3.1/",
    "react-dom": "https://esm.sh/react-dom@18.3.1",
    "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
    "three": "https://esm.sh/three@0.165.0",
    "three/": "https://esm.sh/three@0.165.0/",
    "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.14",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.1/"
  }
}
</script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useRef, useEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
      import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
      import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
      import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment';
      import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

      // --- Types & Enums ---
      const AppState = {
        TREE: 'tree',
        SCATTER: 'scatter',
        ZOOM: 'zoom'
      };

      // --- Components/UIOverlay.tsx ---
      const UIOverlay = ({ 
          statusText, onFileUpload, appState, setAppState, settings, setSettings,
          blessingCount, holdProgress, touchPos, inputMode, setInputMode, videoRef
      }) => {
        const [isExpanded, setIsExpanded] = useState(true);
        const [showHelp, setShowHelp] = useState(false);

        const toggleSetting = (key) => {
          setSettings(prev => ({ ...prev, [key]: !prev[key] }));
        };

        const getStatusColor = () => {
            if (appState === AppState.ZOOM) return "text-amber-400 border-amber-500/50 bg-amber-500/10";
            if (appState === AppState.SCATTER) return "text-cyan-400 border-cyan-500/50 bg-cyan-500/10";
            return "text-green-400 border-green-500/50 bg-green-500/10";
        };

        return (
          <div className="absolute top-0 left-0 w-full h-full pointer-events-none overflow-hidden font-sans select-none">
            
            {/* 1. Permanent Blessing Counter */}
            <div className="absolute bottom-6 left-6 z-20 pointer-events-none">
                <div className="flex items-center gap-3">
                    <div className="text-4xl animate-bounce">â„ï¸</div>
                    <div className="flex flex-col">
                        <span className="text-[10px] text-amber-200/60 uppercase tracking-widest font-bold">Blessings</span>
                        <span className="text-2xl font-light text-white font-mono drop-shadow-[0_0_10px_rgba(255,215,0,0.5)]">
                            Ã— {blessingCount.toString().padStart(3, '0')}
                        </span>
                    </div>
                </div>
            </div>

            {/* 2. Hold Progress Ring */}
            {holdProgress > 0 && (
                <div 
                  className="absolute z-50 pointer-events-none -translate-x-1/2 -translate-y-1/2 transition-transform duration-75 ease-out"
                  style={{ left: touchPos.x, top: touchPos.y }}
                >
                    <div className="relative w-32 h-32 flex items-center justify-center">
                        <div className="absolute inset-0 rounded-full bg-amber-500/20 blur-xl animate-pulse"></div>
                        <div className="absolute inset-0 rounded-full border border-amber-500/30 scale-110 animate-[spin_4s_linear_infinite]"></div>
                        <svg className="w-full h-full -rotate-90 drop-shadow-[0_0_10px_rgba(255,170,0,0.8)]">
                            <circle cx="64" cy="64" r="28" stroke="rgba(255,255,255,0.1)" strokeWidth="4" fill="none" />
                            <circle 
                              cx="64" cy="64" r="28" 
                              stroke="#FFD700" 
                              strokeWidth="4" 
                              fill="none" 
                              strokeDasharray="176" 
                              strokeDashoffset={176 - (176 * holdProgress)}
                              strokeLinecap="round"
                              className="transition-all duration-100 ease-linear"
                            />
                        </svg>
                        {holdProgress >= 1 ? (
                             <span className="absolute text-amber-100 font-bold text-xs animate-ping">READY</span>
                        ) : (
                             <span className="absolute text-amber-100/80 font-mono text-[10px]">{Math.floor(holdProgress * 100)}%</span>
                        )}
                    </div>
                </div>
            )}

            {/* 3. Main Control Panel */}
            <div className="absolute top-4 left-4 z-30 flex flex-col items-start origin-top-left transition-all duration-300 max-w-[90%] w-[320px]">
               <div className="pointer-events-auto w-full flex flex-col bg-black/60 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl overflow-hidden transition-all duration-300">
                  
                  {/* Header */}
                  <div 
                      className="flex items-center justify-between p-4 border-b border-white/10 bg-gradient-to-r from-white/5 to-transparent cursor-pointer hover:bg-white/5 transition-colors"
                      onClick={() => setIsExpanded(!isExpanded)}
                  >
                     <div>
                        <h1 className="text-xl font-light tracking-[0.2em] text-transparent bg-clip-text bg-gradient-to-r from-amber-100 via-amber-300 to-amber-500 uppercase drop-shadow-sm whitespace-nowrap">
                            Jewel Tree
                        </h1>
                     </div>
                     <div className={`shrink-0 w-8 h-8 rounded-full border border-white/10 bg-white/5 flex items-center justify-center text-amber-400 transition-transform duration-300 ${!isExpanded ? '-rotate-90' : 'rotate-0'}`}>
                        â–¼
                     </div>
                  </div>

                  {/* Expanded Content */}
                  <div className={`transition-all duration-500 ease-in-out ${isExpanded ? 'max-h-[80vh] opacity-100' : 'max-h-0 opacity-0'}`}>
                     <div className="p-4 space-y-5 overflow-y-auto max-h-[70vh] scrollbar-thin scrollbar-thumb-white/20">
                        
                        {/* Status Display */}
                        <div className={`flex items-center gap-3 p-3 rounded-lg border ${getStatusColor()} transition-colors duration-300`}>
                            <div className={`w-2 h-2 rounded-full animate-pulse bg-current`}></div>
                            <span className="text-xs font-bold uppercase tracking-widest truncate">{statusText}</span>
                        </div>

                        {/* Picture Insert Button */}
                        <label className="w-full bg-gradient-to-r from-amber-600/80 to-amber-500/80 hover:from-amber-500 hover:to-amber-400 text-white text-xs font-bold py-3 px-4 rounded-xl shadow-lg border border-amber-400/30 cursor-pointer flex items-center justify-center gap-2 transition-all active:scale-95 group">
                            <span className="text-lg group-hover:scale-110 transition-transform">ğŸ“·</span>
                            <span>æ’å…¥ç…§ç‰‡ / Insert Photo</span>
                            <input type="file" multiple accept="image/*" className="hidden" onChange={(e) => onFileUpload(e.target.files)} />
                        </label>

                        {/* Dynamic Interaction Guide */}
                        <div className="space-y-3">
                           <h3 className="text-[10px] font-bold text-white/40 uppercase tracking-widest border-b border-white/10 pb-1">
                              {inputMode === 'touch' ? 'è§¦å±æŒ‡å— (Touch)' : 'AI æ‰‹åŠ¿é­”æ³• (Magic Hand)'}
                           </h3>
                           <div className="grid grid-cols-1 gap-3 text-xs text-gray-300">
                              {inputMode === 'touch' ? (
                                  <>
                                      <div className="flex gap-3">
                                         <div className="w-6 h-6 shrink-0 rounded bg-white/10 flex items-center justify-center text-amber-500">ğŸ‘†</div>
                                         <div className="flex flex-col">
                                            <span className="font-bold text-white">å•æŒ‡ (1 Finger)</span>
                                            <span className="text-[10px] text-white/60">æ—‹è½¬ / ç‚¹å‡»ç…§ç‰‡ / é•¿æŒ‰æ˜Ÿæ˜Ÿ</span>
                                         </div>
                                      </div>
                                      <div className="flex gap-3">
                                         <div className="w-6 h-6 shrink-0 rounded bg-white/10 flex items-center justify-center text-amber-500">âœŒï¸</div>
                                         <div className="flex flex-col">
                                            <span className="font-bold text-white">åŒæŒ‡ (2 Fingers)</span>
                                            <span className="text-[10px] text-white/60">ç¼©æ”¾ / åŒå‡»åˆ‡æ¢æ˜Ÿäº‘</span>
                                         </div>
                                      </div>
                                  </>
                              ) : (
                                  <>
                                      <div className="bg-white/5 p-2 rounded border border-white/5 space-y-2">
                                          <h4 className="font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400 mb-1">
                                              ä»»æ„å•æ‰‹ (Any Hand)
                                          </h4>
                                          
                                          <div className="flex gap-3 items-center">
                                             <div className="w-5 h-5 shrink-0 rounded bg-white/10 flex items-center justify-center text-amber-500">âœŠ</div>
                                             <div className="flex flex-col">
                                                <span className="font-bold text-white">æ¡æ‹³ (Fist)</span>
                                                <span className="text-[10px] text-white/60">æŠ“ä½åœ£è¯æ ‘ + å·¦å³ç§»åŠ¨æ—‹è½¬</span>
                                             </div>
                                          </div>

                                          <div className="flex gap-3 items-center">
                                             <div className="w-5 h-5 shrink-0 rounded bg-white/10 flex items-center justify-center text-cyan-500">ğŸ–</div>
                                             <div className="flex flex-col">
                                                <span className="font-bold text-white">äº”æŒ‡ (5 Fingers)</span>
                                                <span className="text-[10px] text-white/60">æ˜Ÿäº‘æ•£å¼€ (Scatter)</span>
                                             </div>
                                          </div>

                                          <div className="flex gap-3 items-center">
                                             <div className="w-5 h-5 shrink-0 rounded bg-white/10 flex items-center justify-center text-purple-500">â˜ï¸</div>
                                             <div className="flex flex-col">
                                                <span className="font-bold text-white">å•æŒ‡ (Point)</span>
                                                <span className="text-[10px] text-white/60">æ§åˆ¶è¿œè¿‘ (Zoom)</span>
                                             </div>
                                          </div>

                                          <div className="flex gap-3 items-center">
                                             <div className="w-5 h-5 shrink-0 rounded bg-white/10 flex items-center justify-center text-pink-500">ğŸ‘Œ</div>
                                             <div className="flex flex-col">
                                                <span className="font-bold text-white">æåˆ (Pinch)</span>
                                                <span className="text-[10px] text-white/60">ç‚¹å‡»/é€‰æ‹©ç…§ç‰‡</span>
                                             </div>
                                          </div>
                                          
                                          <div className="flex gap-3 items-center">
                                             <div className="w-5 h-5 shrink-0 rounded bg-white/10 flex items-center justify-center text-yellow-500">âœŒï¸</div>
                                             <div className="flex flex-col">
                                                <span className="font-bold text-white">èƒœåˆ© (Victory)</span>
                                                <span className="text-[10px] text-white/60">ä¿æŒ2ç§’è§¦å‘å½©è›‹</span>
                                             </div>
                                          </div>

                                          <div className="flex gap-3 items-center">
                                             <div className="w-5 h-5 shrink-0 rounded bg-white/10 flex items-center justify-center text-yellow-300">ğŸ¤Ÿ</div>
                                             <div className="flex flex-col">
                                                <span className="font-bold text-white">ä¸‰æŒ‡ (Three)</span>
                                                <span className="text-[10px] text-white/60">ä¿æŒ3ç§’çº¯é‡‘æ¨¡å¼</span>
                                             </div>
                                          </div>
                                      </div>
                                  </>
                              )}
                           </div>
                        </div>

                        {/* Settings Toggles */}
                        <div className="grid grid-cols-3 gap-2 pt-2 border-t border-white/10">
                            <button onClick={() => toggleSetting('soundEnabled')} className={`p-2 rounded flex flex-col items-center gap-1 border ${settings.soundEnabled ? 'border-amber-500/30 bg-amber-500/10 text-amber-400' : 'border-white/5 bg-white/5 text-gray-500'}`}>
                               <span className="text-sm">â™ª</span><span className="text-[8px] font-bold">éŸ³æ•ˆ</span>
                            </button>
                            <button onClick={() => toggleSetting('rotationEnabled')} className={`p-2 rounded flex flex-col items-center gap-1 border ${settings.rotationEnabled ? 'border-amber-500/30 bg-amber-500/10 text-amber-400' : 'border-white/5 bg-white/5 text-gray-500'}`}>
                               <span className="text-sm">â†»</span><span className="text-[8px] font-bold">è‡ªæ—‹</span>
                            </button>
                            <button onClick={() => toggleSetting('ribbonVisible')} className={`p-2 rounded flex flex-col items-center gap-1 border ${settings.ribbonVisible ? 'border-amber-500/30 bg-amber-500/10 text-amber-400' : 'border-white/5 bg-white/5 text-gray-500'}`}>
                               <span className="text-sm">ğŸ€</span><span className="text-[8px] font-bold">ä¸å¸¦</span>
                            </button>
                        </div>

                        {/* Back Button */}
                        {appState === AppState.ZOOM && (
                           <button onClick={() => setAppState(AppState.TREE)} className="w-full py-3 rounded-xl bg-white/10 hover:bg-white/20 text-xs text-white border border-white/10 transition-all uppercase tracking-widest flex items-center justify-center gap-2">
                              <span>â†©</span> è¿”å›å…¨æ™¯ (Back)
                           </button>
                        )}
                     </div>
                  </div>
               </div>
            </div>
            
            {/* 4. Camera Preview (Only active in Camera Mode) */}
            <div 
              className={`pointer-events-auto fixed bottom-6 right-6 z-40 w-40 h-32 bg-black/80 rounded-xl border border-white/20 overflow-hidden shadow-2xl transition-all duration-500 ${inputMode === 'camera' ? 'translate-x-0 opacity-100' : 'translate-x-[200%] opacity-0'}`}
            >
                <div className="relative w-full h-full">
                  <video ref={videoRef} id="input-video" className="absolute inset-0 w-full h-full object-cover opacity-50 mirror" playsInline muted autoPlay></video>
                  <canvas id="skeleton-canvas" className="absolute inset-0 w-full h-full object-cover mirror"></canvas>
                  <div className="absolute top-1 left-2 text-[8px] text-cyan-400 font-bold uppercase tracking-widest bg-black/50 px-1 rounded">
                      AI Vision
                  </div>
                </div>
            </div>

            {/* 5. FAB (Only in Touch Mode) */}
            {inputMode === 'touch' && (
                <label className="pointer-events-auto fixed bottom-32 right-8 z-30 group cursor-pointer flex flex-col items-center gap-2">
                   <div className="bg-black/60 backdrop-blur text-white text-[10px] font-bold px-3 py-1.5 rounded-full border border-white/10 shadow-lg whitespace-nowrap">
                      æ’å…¥ç…§ç‰‡ +
                   </div>
                   <input type="file" multiple accept="image/*" className="hidden" onChange={(e) => onFileUpload(e.target.files)} />
                   <div className="w-14 h-14 rounded-full bg-gradient-to-br from-amber-400 to-amber-600 shadow-[0_0_30px_rgba(245,158,11,0.4)] border-2 border-white/20 flex items-center justify-center text-white animate-pulse transition-transform active:scale-90">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                         <path strokeLinecap="round" strokeLinejoin="round" d="M12 4v16m8-8H4" />
                      </svg>
                   </div>
                </label>
            )}

            {/* 6. Close Button */}
            {appState === AppState.ZOOM && (
              <button
                onClick={() => setAppState(AppState.TREE)}
                className="pointer-events-auto fixed top-6 right-6 z-50 w-10 h-10 rounded-full bg-black/40 backdrop-blur-md border border-white/20 text-white/90 flex items-center justify-center transition-all duration-300 hover:bg-white/20 hover:text-white hover:border-white/50 hover:scale-110 hover:shadow-[0_0_15px_rgba(255,255,255,0.8)] active:scale-95 group"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            )}

            {/* 7. Input Mode Toggle Button (Standalone) */}
            {appState !== AppState.ZOOM && (
              <button
                  onClick={() => setInputMode(inputMode === 'touch' ? 'camera' : 'touch')}
                  title={inputMode === 'touch' ? "åˆ‡æ¢åˆ°æ‰‹åŠ¿æ¨¡å¼ (Switch to Gesture)" : "åˆ‡æ¢åˆ°è§¦å±æ¨¡å¼ (Switch to Touch)"}
                  className={`pointer-events-auto fixed top-6 right-[70px] z-30 h-10 px-3 rounded-full backdrop-blur-md border border-white/20 flex items-center justify-center gap-2 transition-all duration-300 hover:scale-105 shadow-lg ${
                      inputMode === 'camera' 
                      ? 'bg-cyan-500/20 text-cyan-400 border-cyan-500/30 shadow-cyan-500/20' 
                      : 'bg-amber-500/20 text-amber-400 border-amber-500/30 shadow-amber-500/20'
                  }`}
              >
                  <span className="text-lg">{inputMode === 'touch' ? 'ğŸ‘†' : 'ğŸ“·'}</span>
                  <span className="text-[10px] font-bold uppercase tracking-widest hidden sm:block">
                      {inputMode === 'touch' ? 'Touch' : 'Gesture'}
                  </span>
              </button>
            )}

            {/* 8. Help Button */}
            {appState !== AppState.ZOOM && (
                <button
                  onClick={() => setShowHelp(true)}
                  className="pointer-events-auto fixed top-6 right-6 z-30 w-10 h-10 rounded-full bg-black/40 backdrop-blur-md border border-white/20 text-white/90 flex items-center justify-center transition-all duration-300 hover:bg-white/20 hover:text-white hover:border-white/50 hover:scale-110 shadow-lg"
                >
                  <span className="text-xl font-bold font-serif italic">?</span>
                </button>
            )}

            {/* 9. Help Modal */}
            {showHelp && (
              <div className="pointer-events-auto fixed inset-0 z-[60] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-300">
                 <div className="bg-gray-900/90 border border-white/10 rounded-2xl max-w-md w-full shadow-2xl overflow-hidden flex flex-col max-h-[85dvh]">
                    <div className="p-4 border-b border-white/10 flex justify-between items-center bg-white/5">
                       <h2 className="text-lg font-bold text-amber-400 tracking-widest uppercase">æ“ä½œæŒ‡å— / Instructions</h2>
                       <button onClick={() => setShowHelp(false)} className="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center text-white hover:bg-white/20">âœ•</button>
                    </div>
                    <div className="p-6 overflow-y-auto space-y-6 text-sm text-gray-300 scrollbar-thin scrollbar-thumb-white/20">
                       <div className="space-y-2">
                          <h3 className="text-white font-bold border-l-4 border-amber-500 pl-3">ğŸŒŸ æ ¸å¿ƒç©æ³•</h3>
                          <p>è¿™ä¸ä»…æ˜¯ä¸€æ£µåœ£è¯æ ‘ï¼Œæ›´æ˜¯ä¸€ä¸ªäº’åŠ¨çš„ç å®è‰ºæœ¯è£…ç½®ã€‚</p>
                       </div>

                       {/* Touch Controls Section */}
                       <div className="space-y-3">
                          <h3 className="text-white font-bold border-l-4 border-amber-500 pl-3">ğŸ‘† è§¦å±æ“ä½œ (Touch)</h3>
                          <ul className="space-y-2 bg-white/5 p-4 rounded-lg text-xs">
                             <li className="flex gap-2 items-center"><span className="text-lg w-6">ğŸ‘†</span> <span><b>å•æŒ‡æ‹–åŠ¨:</b> æ—‹è½¬åœ£è¯æ ‘ã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-lg w-6">ğŸ¤</span> <span><b>åŒæŒ‡æåˆ:</b> ç¼©æ”¾è§†è§’ã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-lg w-6">ğŸ‘†ğŸ‘†</span> <span><b>åŒæŒ‡åŒå‡»:</b> åˆ‡æ¢ æ˜Ÿäº‘/æ ‘ æ¨¡å¼ã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-lg w-6">âœ¨</span> <span><b>é•¿æŒ‰æ˜Ÿæ˜Ÿ:</b> è§¦å‘å²è¯—çº§è®¸æ„¿æ¼”å‡ºã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-lg w-6">ğŸ–</span> <span><b>äº”æŒ‡ç‚¹å‡»:</b> è§¦å‘çº¯é‡‘æ¨¡å¼ã€‚</span></li>
                          </ul>
                       </div>

                       <div className="space-y-3">
                          <h3 className="text-white font-bold border-l-4 border-cyan-500 pl-3">ğŸ¤– AI æ‰‹åŠ¿ (Any Hand)</h3>
                          <p className="text-xs text-white/50 italic">æ— éœ€åŒºåˆ†å·¦å³æ‰‹ã€‚ç³»ç»Ÿè‡ªåŠ¨é”å®šæœ€æ¸…æ™°çš„æ‰‹ã€‚</p>
                          
                          <ul className="space-y-2 bg-white/5 p-4 rounded-lg">
                             <li className="flex gap-2 items-center"><span className="text-2xl w-8">âœŠ</span> <span><b>æ¡æ‹³ (Fist):</b> æŠ“ä½æ ‘ã€‚å·¦å³ç§»åŠ¨æ‰‹æŒ = æ—‹è½¬ã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-2xl w-8">ğŸ–</span> <span><b>äº”æŒ‡ (Open):</b> æ˜Ÿäº‘æ•£å¼€ã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-2xl w-8">â˜ï¸</span> <span><b>å•æŒ‡ (Point):</b> æ§åˆ¶è¿œè¿‘ (Zoom)ã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-2xl w-8">ğŸ‘Œ</span> <span><b>æåˆ (Pinch):</b> ç‚¹å‡»/é€‰æ‹©ç…§ç‰‡ã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-2xl w-8">ğŸ¤Ÿ</span> <span><b>ä¸‰æŒ‡ (Three):</b> ä¿æŒ3ç§’çº¯é‡‘æ¨¡å¼ã€‚</span></li>
                             <li className="flex gap-2 items-center"><span className="text-2xl w-8">âœŒï¸</span> <span><b>èƒœåˆ© (Victory):</b> ä¿æŒ2ç§’è§¦å‘å½©è›‹ã€‚</span></li>
                          </ul>
                       </div>
                    </div>
                    <div className="p-4 border-t border-white/10 bg-white/5">
                       <button onClick={() => setShowHelp(false)} className="w-full py-3 bg-gradient-to-r from-amber-600 to-amber-500 rounded-xl text-white font-bold shadow-lg hover:brightness-110 active:scale-95 transition-all">
                          å¼€å§‹ä½“éªŒ / Start
                       </button>
                    </div>
                 </div>
              </div>
            )}

          </div>
        );
      };

      // --- Components/JewelTreeScene.tsx ---
      const CONFIG = {
        goldCount: 800, 
        silverCount: 800,
        gemCount: 400,
        emeraldCount: 400,
        dustCount: 1200,
        treeHeight: 75,
        maxRadius: 30
      };

      const JewelTreeScene = ({ 
        appState, setAppState, setStatusText, uploadedImages, setAuroraActive, settings,
        setBlessingCount, setHoldProgress, setTouchPos, inputMode, videoRef
      }) => {
        const containerRef = useRef(null);
        const requestRef = useRef(null);
        
        // Three.js Refs
        const sceneRef = useRef(null);
        const cameraRef = useRef(null);
        const rendererRef = useRef(null);
        const mainGroupRef = useRef(null);
        
        // Logic Data Refs
        const logicDataRef = useRef({
          gold: [],
          silver: [],
          gem: [],
          emerald: [],
          dust: [],
          star: null,
          ribbon: null,
          fireworks: [],
          textTargets: null
        });
        
        const photoMeshesRef = useRef([]);
        const zoomTargetIndexRef = useRef(-1);
        const timeRef = useRef(0);
        const audioContextRef = useRef(null);
        
        // Interaction/State Refs
        const isGoldModeRef = useRef(false);
        const goldModeTimerRef = useRef(0);
        const shakeIntensityRef = useRef(0);
        const rotationVelocityRef = useRef(0);
        
        // Epic Sequence Refs
        const isEpicSequenceRef = useRef(false);
        const epicTimerRef = useRef(0);
        const isHoldingStarRef = useRef(false);
        const starHoldStartTimeRef = useRef(0);
        const hasTriggeredEpicRef = useRef(false);
        const rainbowStarModeRef = useRef(false);

        // Interaction Vectors
        const interactionRef = useRef({
          touches: 0, lastDistance: 0, lastAngle: 0, startPositions: [], startTime: 0, lastTapTime: 0
        });
        const repulsionPointRef = useRef(null);
        const raycasterRef = useRef(new THREE.Raycaster());
        const planeRef = useRef(new THREE.Plane(new THREE.Vector3(0, 0, 1), 0));

        // MediaPipe Refs
        const handLandmarkerRef = useRef(null);
        const lastVideoTimeRef = useRef(-1);
        const gestureStateRef = useRef({
          isPinching: false,
          victoryTimer: 0,
          threeTimer: 0,
        });

        // State Mirror
        const appStateRef = useRef(appState);
        const settingsRef = useRef(settings);
        const inputModeRef = useRef(inputMode);

        useEffect(() => {
          appStateRef.current = appState;
          settingsRef.current = settings;
          inputModeRef.current = inputMode;
          if (inputMode === 'touch') {
              if (appState === AppState.TREE) setStatusText("çŠ¶æ€ï¼šåœ£è¯æ ‘ (é•¿æŒ‰æ˜Ÿæ˜Ÿè®¸æ„¿)");
              if (appState === AppState.SCATTER) setStatusText("çŠ¶æ€ï¼šæ˜Ÿäº‘æ•£å¼€ (åŒæŒ‡ç‚¹å‡»å¤åŸ)");
              if (appState === AppState.ZOOM) setStatusText("çŠ¶æ€ï¼šç…§ç‰‡è¯¦æƒ…");
          }
        }, [appState, settings, inputMode, setStatusText]);

        useEffect(() => {
          if (!mainGroupRef.current) return;
          if (uploadedImages.length > photoMeshesRef.current.length) {
              const newImages = uploadedImages.slice(photoMeshesRef.current.length);
              newImages.forEach(img => addPhotoMesh(img));
              setStatusText(`å·²æ·»åŠ ç…§ç‰‡ (${uploadedImages.length})`);
          }
        }, [uploadedImages, setStatusText]);

        // --- MediaPipe Initialization ---
        useEffect(() => {
            let stream = null;
            let isCancelled = false;

            if (inputMode === 'camera') {
                const initVision = async () => {
                    try {
                        setStatusText("åˆå§‹åŒ–: æ£€æŸ¥ç¯å¢ƒ...");

                        if (!window.isSecureContext && window.location.hostname !== 'localhost') {
                            throw new Error("æ‘„åƒå¤´éœ€ HTTPS æˆ– Localhost ç¯å¢ƒ");
                        }
                        
                        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                            throw new Error("æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ API");
                        }

                        setStatusText("åˆå§‹åŒ–: åŠ è½½ AI æ¨¡å‹...");

                        const vision = await FilesetResolver.forVisionTasks(
                            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
                        );
                        
                        if (isCancelled) return;
                        
                        handLandmarkerRef.current = await HandLandmarker.createFromOptions(vision, {
                            baseOptions: {
                                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                                delegate: "GPU"
                            },
                            runningMode: "VIDEO", 
                            numHands: 1, 
                            minHandDetectionConfidence: 0.3,
                            minHandPresenceConfidence: 0.3,
                            minTrackingConfidence: 0.3
                        });

                        setStatusText("åˆå§‹åŒ–: è¯·æ±‚æ‘„åƒå¤´æƒé™...");
                        
                        if (videoRef.current) {
                            const video = videoRef.current;
                            
                            try {
                                stream = await navigator.mediaDevices.getUserMedia({ 
                                    video: { 
                                        facingMode: "user",
                                        width: { ideal: 640 },
                                        height: { ideal: 480 }
                                    },
                                    audio: false
                                });
                            } catch (err) {
                                console.warn("Standard constraints failed, trying basic...", err);
                                try {
                                   stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                                } catch (err2) {
                                   if (err2.name === 'NotAllowedError' || err2.name === 'PermissionDeniedError') {
                                      throw new Error("è¯·å…è®¸æ‘„åƒå¤´æƒé™");
                                   } else if (err2.name === 'NotFoundError') {
                                      throw new Error("æœªæ£€æµ‹åˆ°æ‘„åƒå¤´");
                                   } else {
                                      throw new Error(`æ— æ³•å¼€å¯æ‘„åƒå¤´: ${err2.message}`);
                                   }
                                }
                            }

                            if (isCancelled) {
                                if (stream) stream.getTracks().forEach(t => t.stop());
                                return;
                            }
                            
                            video.srcObject = stream;
                            video.onloadedmetadata = () => {
                                video.play().catch(e => console.error("Video play failed", e));
                            };
                            
                            video.onloadeddata = () => {
                                setStatusText("AI Ready: è¯·ä¸¾èµ·ä¸€åªæ‰‹ ğŸ‘‹");
                            };
                        } else {
                            setStatusText("Error: è§†é¢‘ç»„ä»¶æœªåŠ è½½");
                        }
                    } catch (err) {
                        console.error("Camera/AI initialization failed:", err);
                        setStatusText(`Error: ${err.message || "åˆå§‹åŒ–å¤±è´¥"}`);
                    }
                };
                initVision();
            } else {
                handLandmarkerRef.current = null;
                if (videoRef.current && videoRef.current.srcObject) {
                    const tracks = videoRef.current.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    videoRef.current.srcObject = null;
                }
            }

            return () => {
                isCancelled = true;
                if (stream) {
                    stream.getTracks().forEach(t => t.stop());
                }
            };
        }, [inputMode]);

        // --- Main 3D Initialization ---
        useEffect(() => {
          if (!containerRef.current) return;

          logicDataRef.current.gold = [];
          logicDataRef.current.silver = [];
          logicDataRef.current.gem = [];
          logicDataRef.current.emerald = [];
          logicDataRef.current.dust = [];
          logicDataRef.current.fireworks = [];
          logicDataRef.current.textTargets = null;
          photoMeshesRef.current = [];

          const width = containerRef.current.clientWidth;
          const height = containerRef.current.clientHeight;
          if (width === 0 || height === 0) return;

          const scene = new THREE.Scene();
          sceneRef.current = scene;

          const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
          camera.position.set(0, 0, 110);
          cameraRef.current = camera;

          const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
          renderer.setSize(width, height);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
          renderer.toneMapping = THREE.ACESFilmicToneMapping;
          renderer.toneMappingExposure = 1.0;
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;

          containerRef.current.appendChild(renderer.domElement);
          rendererRef.current = renderer;

          const pmremGenerator = new THREE.PMREMGenerator(renderer);
          scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

          const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
          scene.add(ambientLight);
          
          const spotLight = new THREE.SpotLight(0xffddaa, 100);
          spotLight.position.set(30, 60, 50);
          spotLight.angle = Math.PI / 4;
          spotLight.penumbra = 0.5;
          spotLight.castShadow = true;
          spotLight.shadow.mapSize.width = 1024;
          spotLight.shadow.mapSize.height = 1024;
          scene.add(spotLight);
          
          const blueLight = new THREE.PointLight(0xaaddff, 40, 100);
          blueLight.position.set(-30, -20, 30);
          scene.add(blueLight);

          const frontLight = new THREE.DirectionalLight(0xffffff, 1.5);
          frontLight.position.set(0, 10, 100);
          frontLight.castShadow = false;
          scene.add(frontLight);

          const renderScene = new RenderPass(scene, camera);
          const bloomPass = new UnrealBloomPass(new THREE.Vector2(width, height), 1.5, 0.4, 0.85);
          bloomPass.threshold = 0.3;
          bloomPass.strength = 0.6;
          bloomPass.radius = 0.5;

          const composer = new EffectComposer(renderer);
          composer.addPass(renderScene);
          composer.addPass(bloomPass);

          const mainGroup = new THREE.Group();
          scene.add(mainGroup);
          mainGroupRef.current = mainGroup;

          const randomSpherePoint = (r) => {
              const u = Math.random(), v = Math.random();
              const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
              return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
          };

          const createInstancedMesh = (geo, mat, count, dataArray, name) => {
              const mesh = new THREE.InstancedMesh(geo, mat, count);
              mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
              mesh.castShadow = true;
              mesh.receiveShadow = true;
              mesh.name = name; 
              mainGroup.add(mesh);
              
              for (let i = 0; i < count; i++) {
                  const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                  const normH = (h + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                  const rMax = CONFIG.maxRadius * (1 - normH);
                  const r = Math.sqrt(Math.random()) * rMax; 
                  const theta = Math.random() * Math.PI * 2;
                  const treePos = new THREE.Vector3(r * Math.cos(theta), h, r * Math.sin(theta));
                  const scatterPos = randomSpherePoint(40 + Math.random()*40);

                  dataArray.push({
                      treePos: treePos,
                      scatterPos: scatterPos,
                      currentPos: treePos.clone(),
                      scale: 0.6 + Math.random() * 0.8,
                      rotSpeed: new THREE.Euler(Math.random()*0.03, Math.random()*0.03, Math.random()*0.03),
                      rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0)
                  });
              }
          };

          const createMaterialsAndMeshes = () => {
              const goldMat = new THREE.MeshPhysicalMaterial({ color: 0xffaa00, metalness: 1.0, roughness: 0.15, clearcoat: 1.0, emissive: 0xaa5500, emissiveIntensity: 0.1 });
              goldMat.userData = { origEmissive: 0xaa5500, origEmissiveIntensity: 0.1 };

              const silverMat = new THREE.MeshPhysicalMaterial({ color: 0xeeeeee, metalness: 0.9, roughness: 0.2, clearcoat: 1.0, emissive: 0x222222, emissiveIntensity: 0.1 });
              silverMat.userData = { origEmissive: 0x222222, origEmissiveIntensity: 0.1 };

              const gemMat = new THREE.MeshPhysicalMaterial({ color: 0xff0044, metalness: 0.1, roughness: 0.0, transmission: 0.5, thickness: 1.0, emissive: 0x440011, emissiveIntensity: 0.3 });
              gemMat.userData = { origEmissive: 0x440011, origEmissiveIntensity: 0.3 };

              const emeraldMat = new THREE.MeshPhysicalMaterial({ color: 0x00aa55, metalness: 0.2, roughness: 0.1, transmission: 0.4, thickness: 1.5, emissive: 0x002211, emissiveIntensity: 0.2 });
              emeraldMat.userData = { origEmissive: 0x002211, origEmissiveIntensity: 0.2 };

              const sphereGeo = new THREE.SphereGeometry(0.7, 16, 16);
              const boxGeo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
              const diamondGeo = new THREE.OctahedronGeometry(0.8, 0);
              const coneGeo = new THREE.ConeGeometry(0.5, 1.2, 8);

              createInstancedMesh(sphereGeo, goldMat, CONFIG.goldCount, logicDataRef.current.gold, 'gold');
              createInstancedMesh(boxGeo, silverMat, CONFIG.silverCount, logicDataRef.current.silver, 'silver');
              createInstancedMesh(diamondGeo, gemMat, CONFIG.gemCount, logicDataRef.current.gem, 'gem');
              createInstancedMesh(coneGeo, emeraldMat, CONFIG.emeraldCount, logicDataRef.current.emerald, 'emerald');

              const star = new THREE.Mesh(
                  new THREE.OctahedronGeometry(3.0, 0), 
                  new THREE.MeshPhysicalMaterial({ color: 0xffffff, metalness:0.8, roughness:0, emissive:0xffffee, emissiveIntensity:1 })
              );
              star.userData = { treePos: new THREE.Vector3(0, CONFIG.treeHeight/2 + 2, 0), scatterPos: new THREE.Vector3(0, 60, 0) };
              star.position.copy(star.userData.treePos);
              mainGroup.add(star);
              logicDataRef.current.star = star;
          };

          const createDust = () => {
              const geo = new THREE.BufferGeometry();
              const pos = [];
              for(let i=0; i<CONFIG.dustCount; i++) {
                  const h = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
                  const r = Math.random() * CONFIG.maxRadius * (1 - (h + CONFIG.treeHeight/2)/CONFIG.treeHeight) + 2; 
                  const theta = Math.random() * Math.PI * 2;
                  pos.push(r*Math.cos(theta), h, r*Math.sin(theta));
                  logicDataRef.current.dust.push({
                      treePos: new THREE.Vector3(r*Math.cos(theta), h, r*Math.sin(theta)),
                      scatterPos: randomSpherePoint(60),
                      currentPos: new THREE.Vector3(r*Math.cos(theta), h, r*Math.sin(theta))
                  });
              }
              geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
              const dustSystem = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffee, size: 0.6, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false }));
              dustSystem.userData = { isDust: true };
              mainGroup.add(dustSystem);
          };

          const createStarField = () => {
              const geo = new THREE.BufferGeometry();
              const pos = [];
              for(let i=0; i<1000; i++) pos.push((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
              geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
              const stars = new THREE.Points(geo, new THREE.PointsMaterial({color: 0x888888, size: 1.2, transparent: true, opacity: 0.5}));
              scene.add(stars);
          };

          const createRibbonWithMorph = () => {
              const spiralPoints = [];
              const turns = 5;
              const height = CONFIG.treeHeight + 10;
              const steps = 300; 
              for (let i = 0; i <= steps; i++) {
                  const t = i / steps;
                  const angle = t * Math.PI * 2 * turns;
                  const y = (t - 0.5) * height; 
                  const normH = (y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                  const r = (CONFIG.maxRadius + 5) * (1 - Math.max(0, normH*0.8));
                  spiralPoints.push(new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r));
              }

              const framePoints = [];
              const w = 90; 
              const topY = 40;
              const botY = -30;
              const corners = [
                  new THREE.Vector3(w, topY, 0),
                  new THREE.Vector3(-w, topY, 0),
                  new THREE.Vector3(-w, botY, 0),
                  new THREE.Vector3(w, botY, 0),
                  new THREE.Vector3(w, topY, 0)
              ];
              const frameCurve = new THREE.CatmullRomCurve3(corners, true, 'catmullrom', 0.1); 
              for (let i = 0; i <= steps; i++) {
                  framePoints.push(frameCurve.getPoint(i / steps));
              }

              const spiralCurve = new THREE.CatmullRomCurve3(spiralPoints);
              const spiralGeo = new THREE.TubeGeometry(spiralCurve, steps, 0.5, 4, false);
              const frameCurveFinal = new THREE.CatmullRomCurve3(framePoints);
              const frameGeo = new THREE.TubeGeometry(frameCurveFinal, steps, 0.5, 4, false);

              spiralGeo.morphAttributes.position = [];
              spiralGeo.morphAttributes.position[0] = frameGeo.attributes.position;
              
              const canvas = document.createElement('canvas');
              canvas.width = 2048; canvas.height = 128;
              const ctx = canvas.getContext('2d');
              if (ctx) {
                  ctx.fillStyle = 'rgba(139, 0, 0, 0.6)'; ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.fillStyle = '#8B0000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                  ctx.fillStyle = '#FFD700'; ctx.fillRect(0, 0, canvas.width, 10); ctx.fillRect(0, canvas.height-10, canvas.width, 10);
                  ctx.font = 'bold 70px "Times New Roman", serif'; ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                  const text = "åœ£è¯å¿«ä¹ï¼  ğŸ„  Merry Christmas!  â„ï¸  ";
                  const repeats = Math.ceil(canvas.width / ctx.measureText(text).width) + 1;
                  for(let i=0; i<repeats; i++) ctx.fillText(text, (i * ctx.measureText(text).width) + 300, canvas.height/2);
              }
              const texture = new THREE.CanvasTexture(canvas);
              texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.ClampToEdgeWrapping; texture.repeat.set(5, 1);

              const material = new THREE.MeshStandardMaterial({
                  map: texture, side: THREE.DoubleSide, roughness: 0.4, metalness: 0.3, 
                  emissive: 0x550000, emissiveIntensity: 0.1, transparent: true, opacity: 0.6
              });

              const ribbon = new THREE.Mesh(spiralGeo, material);
              ribbon.morphTargetInfluences = [0]; 
              mainGroup.add(ribbon);
              logicDataRef.current.ribbon = ribbon;
          };

          const createTextTargets = () => {
              const canvas = document.createElement('canvas');
              canvas.width = 400; canvas.height = 200; 
              const ctx = canvas.getContext('2d');
              if (!ctx) return;

              const scanPixels = (text, font, offsetY) => {
                  ctx.clearRect(0, 0, 400, 200);
                  ctx.fillStyle = '#FFFFFF';
                  ctx.font = font;
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillText(text, 200, 100);
                  
                  const imageData = ctx.getImageData(0, 0, 400, 200).data;
                  const points = [];
                  for (let y = 0; y < 200; y += 3) {
                      for (let x = 0; x < 400; x += 3) {
                          if (imageData[(y * 400 + x) * 4 + 3] > 128) {
                              points.push(new THREE.Vector3((x - 200) * 0.4, (100 - y) * 0.4 + offsetY, 25));
                          }
                      }
                  }
                  return points;
              };
              const goldTargets = scanPixels("Merry Christmas!", "bold 48px Georgia", 20); 
              const silverTargets = scanPixels("åœ£è¯å¿«ä¹ï¼", "bold 60px 'Microsoft YaHei'", -20);
              logicDataRef.current.textTargets = { gold: goldTargets, silver: silverTargets };
          };

          createMaterialsAndMeshes();
          createDust();
          createStarField();
          createRibbonWithMorph();
          createTextTargets();

          // --- Gesture Prediction Engine (Single Hand Master) ---
          const predictWebcam = () => {
              if (!handLandmarkerRef.current || !videoRef.current || inputModeRef.current !== 'camera') return;
              const video = videoRef.current;
              if (video.readyState < 2 || video.videoWidth === 0) return;

              if (video.currentTime !== lastVideoTimeRef.current) {
                  lastVideoTimeRef.current = video.currentTime;
                  
                  try {
                      const result = handLandmarkerRef.current.detectForVideo(video, Date.now());
                      const canvas = document.getElementById('skeleton-canvas');
                      if (canvas && canvas.getContext('2d')) {
                          const ctx = canvas.getContext('2d');
                          ctx.clearRect(0, 0, canvas.width, canvas.height);
                          if (canvas.width !== video.videoWidth) canvas.width = video.videoWidth;
                          if (canvas.height !== video.videoHeight) canvas.height = video.videoHeight;
                          
                          if (result.landmarks && result.landmarks.length > 0) {
                              const landmarks = result.landmarks[0]; 

                              ctx.lineWidth = 3; ctx.strokeStyle = '#FFD700'; ctx.fillStyle = '#FF4400';
                              const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
                              ctx.beginPath();
                              connections.forEach(([s, e]) => {
                                  ctx.moveTo(landmarks[s].x * canvas.width, landmarks[s].y * canvas.height);
                                  ctx.lineTo(landmarks[e].x * canvas.width, landmarks[e].y * canvas.height);
                              });
                              ctx.stroke();

                              const dist = (i1, i2) => {
                                  const dx = landmarks[i1].x - landmarks[i2].x;
                                  const dy = landmarks[i1].y - landmarks[i2].y;
                                  const dz = landmarks[i1].z - landmarks[i2].z;
                                  return Math.sqrt(dx*dx + dy*dy + dz*dz);
                              };
                              const isExt = (tip, pip) => dist(0, tip) > dist(0, pip) * 1.1;

                              const thumbOpen = isExt(4, 2);
                              const indexOpen = isExt(8, 6);
                              const midOpen = isExt(12, 10);
                              const ringOpen = isExt(16, 14);
                              const pinkyOpen = isExt(20, 18);
                              const extendedCount = (thumbOpen?1:0)+(indexOpen?1:0)+(midOpen?1:0)+(ringOpen?1:0)+(pinkyOpen?1:0);

                              const isFist = !indexOpen && !midOpen && !ringOpen && !pinkyOpen;
                              const isOpen = extendedCount === 5;
                              const isPointing = indexOpen && !midOpen && !ringOpen && !pinkyOpen;
                              const isVictory = indexOpen && midOpen && !ringOpen && !pinkyOpen;
                              const isThreeFinger = indexOpen && midOpen && ringOpen && !pinkyOpen;
                              const pinchDist = dist(4, 8);
                              const isPinch = pinchDist < 0.05;

                              let status = "AI: ";

                              if (isPointing) {
                                  status += "â˜ï¸ Point (Zoom)";
                                  const handSize = dist(0, 12); 
                                  if (cameraRef.current) {
                                      let targetZ = 250 - (handSize * 600);
                                      targetZ = Math.max(30, Math.min(220, targetZ));
                                      cameraRef.current.position.z = THREE.MathUtils.lerp(cameraRef.current.position.z, targetZ, 0.05);
                                  }
                              }

                              if (isFist) {
                                  status += "âœŠ Fist (Spin)";
                                  if (appStateRef.current !== AppState.TREE) setAppState(AppState.TREE);
                                  
                                  const palmX = landmarks[9].x; 
                                  const deviation = palmX - 0.5; 
                                  
                                  if (Math.abs(deviation) > 0.05) {
                                      rotationVelocityRef.current = -deviation * 0.2; 
                                      if (mainGroupRef.current) mainGroupRef.current.rotation.y += rotationVelocityRef.current;
                                  }
                              } 
                              else if (isOpen) {
                                  status += "ğŸ– Open (Scatter)";
                                  if (appStateRef.current !== AppState.SCATTER) setAppState(AppState.SCATTER);
                              }
                              else if (isPinch) {
                                   status += "ğŸ‘Œ Pinch (Select)";
                                   if (!gestureStateRef.current.isPinching) {
                                       playBellSound();
                                       if (containerRef.current) {
                                           const rect = containerRef.current.getBoundingClientRect();
                                           const rawX = (landmarks[4].x + landmarks[8].x) / 2;
                                           const rawY = (landmarks[4].y + landmarks[8].y) / 2;
                                           const screenX = (1 - rawX) * rect.width + rect.left;
                                           const screenY = rawY * rect.height + rect.top;
                                           handlePhotoClick(screenX, screenY);
                                       }
                                   }
                                   gestureStateRef.current.isPinching = true;
                              } 
                              else if (isVictory) {
                                  status += `âœŒï¸ Victory (${Math.floor(gestureStateRef.current.victoryTimer)}s)`;
                                  gestureStateRef.current.victoryTimer += 0.03;
                                   if (gestureStateRef.current.victoryTimer > 2.0 && !isEpicSequenceRef.current) {
                                       hasTriggeredEpicRef.current = true;
                                       isEpicSequenceRef.current = true;
                                       epicTimerRef.current = 0;
                                       playWeWishYou();
                                       setBlessingCount(prev => prev + 1);
                                       rainbowStarModeRef.current = true;
                                       gestureStateRef.current.victoryTimer = 0;
                                  }
                              }
                              else if (isThreeFinger) {
                                  status += `ğŸ¤Ÿ Gold (${Math.floor(gestureStateRef.current.threeTimer)}s)`;
                                  gestureStateRef.current.threeTimer += 0.03;
                                  if (gestureStateRef.current.threeTimer > 3.0) {
                                      isGoldModeRef.current = true;
                                      goldModeTimerRef.current = 8.0; 
                                      playJingleBells(); 
                                      gestureStateRef.current.threeTimer = 0;
                                  }
                              }
                              else {
                                  status += "Tracing...";
                                  gestureStateRef.current.isPinching = false;
                                  gestureStateRef.current.victoryTimer = 0;
                                  gestureStateRef.current.threeTimer = 0;
                              }

                              setStatusText(status);

                              const cursorX = (1 - landmarks[8].x) * canvas.width; 
                              const cursorY = landmarks[8].y * canvas.height;
                              ctx.beginPath();
                              ctx.arc(cursorX, cursorY, 8, 0, 2*Math.PI);
                              ctx.fillStyle = isPinch ? '#00FF00' : '#FFFFFF';
                              ctx.fill();
                              ctx.strokeStyle = '#000000';
                              ctx.stroke();

                          } else {
                              setStatusText("AI: å¯»æ‰¾æ‰‹æŒ...");
                          }
                      }
                  } catch(e) {}
              }
          };

          const spawnFirework = (colorOverride, type = 'normal') => {
              const colors = colorOverride ? [colorOverride] : [0xff0000, 0xffd700, 0x00ff00];
              const color = colors[Math.floor(Math.random() * colors.length)];
              const cx = (Math.random() - 0.5) * 40;
              const cy = 20; 
              const cz = (Math.random() - 0.5) * 40;
              
              const rocket = {
                  pos: new THREE.Vector3(cx, -30, cz),
                  vel: new THREE.Vector3(0, 1.5 + Math.random(), 0),
                  targetY: 40 + Math.random() * 20,
                  life: 1.0,
                  color: color,
                  isRocket: true,
                  type: type
              };
              logicDataRef.current.fireworks.push(rocket);
          };

          const explodeFirework = (rocket) => {
              const count = rocket.type === 'snow' ? 60 : 30;
              for(let i=0; i<count; i++) {
                  logicDataRef.current.fireworks.push({
                      pos: rocket.pos.clone(),
                      vel: new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)).normalize().multiplyScalar(0.5 + Math.random()),
                      life: rocket.type === 'snow' ? 3.0 : 1.0,
                      color: rocket.type === 'snow' ? 0xFFFFFF : rocket.color, 
                      type: rocket.type,
                      isParticle: true
                  });
              }
          };

          const updateInstancedSystem = (dataArray, group, state, type) => {
              const mesh = group.children.find(c => c.name === type);
              if (!mesh) return;

              const dummy = new THREE.Object3D();
              const isGold = isGoldModeRef.current;
              const isEpic = isEpicSequenceRef.current;
              const epicTime = epicTimerRef.current;
              const repelPos = repulsionPointRef.current;

              const mat = mesh.material;
              
              const formingText = isEpic && epicTime > 4.0 && epicTime < 16.0;
              const textTargets = logicDataRef.current.textTargets;
              
              if (formingText) {
                   if (type === 'gold') {
                       mat.color.setHex(0xFFD700); 
                       mat.emissive.setHex(0xFFAA00);
                       mat.emissiveIntensity = 2.0 + Math.sin(timeRef.current * 5); 
                   } else if (type === 'silver' || type === 'gem') {
                       mat.color.setHex(0xD40000); 
                       mat.emissive.setHex(0xFF0000); 
                       mat.emissiveIntensity = 1.0 + Math.sin(timeRef.current * 8); 
                   } else {
                       mat.emissiveIntensity = 0.1;
                   }
              } else if (isGold || (isEpic && epicTime < 3.0)) {
                  mat.emissive.setHex(0xFFAA00);
                  mat.emissiveIntensity = 2.0;
              } else {
                  mat.color.setHex(type === 'gold' ? 0xffaa00 : type === 'silver' ? 0xeeeeee : type === 'gem' ? 0xff0044 : 0x00aa55);
                  mat.emissive.setHex(mesh.userData.origEmissive || 0x000000);
                  mat.emissiveIntensity = mesh.userData.origEmissiveIntensity || 0.1;
              }

              for (let i = 0; i < dataArray.length; i++) {
                  const item = dataArray[i];
                  let target = state === AppState.TREE ? item.treePos : item.scatterPos;
                  if (state === AppState.ZOOM) target = item.scatterPos;

                  if (formingText && textTargets) {
                      if (type === 'gold' && textTargets.gold.length > 0) {
                          target = textTargets.gold[i % textTargets.gold.length];
                      } 
                      else if ((type === 'silver' || type === 'gem') && textTargets.silver.length > 0) {
                          target = textTargets.silver[i % textTargets.silver.length];
                      }
                  }

                  if (repelPos && state === AppState.TREE && !isEpic) {
                      const localRepel = repelPos.clone().applyMatrix4(group.matrixWorld.clone().invert());
                      if (item.currentPos.distanceTo(localRepel) < 18.0) {
                          const pushDir = item.currentPos.clone().sub(localRepel).normalize();
                          item.currentPos.add(pushDir.multiplyScalar(0.2));
                      }
                  }

                  const speed = formingText ? 0.08 : 0.05;
                  item.currentPos.lerp(target, speed);
                  item.rotation.x += item.rotSpeed.x;
                  item.rotation.y += item.rotSpeed.y;

                  dummy.position.copy(item.currentPos);
                  dummy.rotation.copy(item.rotation);
                  let s = item.scale;
                  if (state === AppState.ZOOM) s *= 0.5;
                  if (formingText) s *= 0.8; 
                  dummy.scale.setScalar(s);
                  dummy.updateMatrix();
                  mesh.setMatrixAt(i, dummy.matrix);
              }
              mesh.instanceMatrix.needsUpdate = true;
          };

          const updateDustParticles = (state) => {
              const dustSystem = mainGroup.children.find(c => c.userData.isDust);
              if(!dustSystem) return;
              const positions = dustSystem.geometry.attributes.position.array;
              const speedBoost = interactionRef.current.touches >= 3 ? 5.0 : 1.0;
              for(let i=0; i<logicDataRef.current.dust.length; i++) {
                  const item = logicDataRef.current.dust[i];
                  if (state === AppState.TREE) {
                      item.currentPos.y += 0.05 * speedBoost;
                      if(item.currentPos.y > CONFIG.treeHeight/2) item.currentPos.y = -CONFIG.treeHeight/2;
                      const normH = (item.currentPos.y + CONFIG.treeHeight/2) / CONFIG.treeHeight;
                      const rMax = CONFIG.maxRadius * (1-normH) + 2;
                      if(Math.sqrt(item.currentPos.x**2 + item.currentPos.z**2) > rMax) {
                          item.currentPos.x *= 0.98;
                          item.currentPos.z *= 0.98;
                      }
                  } else {
                      item.currentPos.lerp(item.scatterPos, 0.05);
                  }
                  positions[i*3] = item.currentPos.x;
                  positions[i*3+1] = item.currentPos.y;
                  positions[i*3+2] = item.currentPos.z;
              }
              dustSystem.geometry.attributes.position.needsUpdate = true;
          };

          const updateFireworks = () => {
              let fwSystem = mainGroup.children.find(c => c.name === 'fireworks');
              if (!fwSystem) {
                  const geo = new THREE.BufferGeometry();
                  const mat = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true });
                  fwSystem = new THREE.Points(geo, mat);
                  fwSystem.name = 'fireworks';
                  mainGroup.add(fwSystem);
              }
              const activeFW = logicDataRef.current.fireworks;
              fwSystem.visible = activeFW.length > 0;
              if (!fwSystem.visible) return;

              const positions = [];
              const colors = [];
              for (let i = activeFW.length - 1; i >= 0; i--) {
                  const p = activeFW[i];
                  if (p.isRocket) {
                      p.pos.add(p.vel);
                      if (p.pos.y >= p.targetY) {
                          explodeFirework(p);
                          activeFW.splice(i, 1);
                      } else {
                          positions.push(p.pos.x, p.pos.y, p.pos.z);
                          const c = new THREE.Color(p.color);
                          colors.push(c.r, c.g, c.b);
                      }
                      continue;
                  }
                  p.life -= 0.01;
                  p.pos.add(p.vel);
                  if (p.type === 'snow') {
                      p.vel.multiplyScalar(0.95);
                      p.vel.y -= 0.005;
                      p.pos.lerp(new THREE.Vector3(0, -CONFIG.treeHeight/2, 0), 0.005);
                  } else {
                      p.vel.y -= 0.01;
                  }
                  if (p.life <= 0) {
                      activeFW.splice(i, 1);
                  } else {
                      positions.push(p.pos.x, p.pos.y, p.pos.z);
                      const c = new THREE.Color(p.color);
                      colors.push(c.r, c.g, c.b);
                  }
              }
              fwSystem.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
              fwSystem.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
              fwSystem.geometry.computeBoundingSphere();
          };

          const updateRibbon = (state) => {
              const ribbon = logicDataRef.current.ribbon;
              if (ribbon) {
                  ribbon.visible = settingsRef.current.ribbonVisible;
                  if (!ribbon.visible) return;
                  const isEpic = isEpicSequenceRef.current;
                  const time = timeRef.current;
                  const mat = ribbon.material;

                  if (isEpic) {
                      const epicProgress = Math.min(epicTimerRef.current / 3.0, 1.0);
                      const t = THREE.MathUtils.smoothstep(epicProgress, 0, 1);
                      if (ribbon.morphTargetInfluences) ribbon.morphTargetInfluences[0] = t;
                      ribbon.rotation.set(0, 0, 0); 
                      ribbon.scale.set(1, 1, 1);
                      ribbon.position.set(0, 5, 0); 
                      mat.emissive.setHex(0xFFD700);
                      mat.emissiveIntensity = 1.0 + Math.sin(time * 5.0) * 0.5;
                      mat.opacity = 0.9;
                      if (cameraRef.current) {
                           const cam = cameraRef.current;
                           const aspect = cam.aspect;
                           const vFOV = cam.fov * Math.PI / 180;
                           const targetDistH = 50 / Math.tan(vFOV / 2);
                           const targetDistW = 90 / (aspect * Math.tan(vFOV / 2));
                           const targetZ = Math.max(targetDistH, targetDistW, 110);
                           cam.position.z = THREE.MathUtils.lerp(cam.position.z, targetZ, 0.05);
                      }
                  } else {
                      if (ribbon.morphTargetInfluences) ribbon.morphTargetInfluences[0] = THREE.MathUtils.lerp(ribbon.morphTargetInfluences[0], 0, 0.1);
                      const waveSpeed = 0.5;
                      const waveAmp = 1.5;
                      ribbon.position.set(0, Math.sin(time * waveSpeed) * waveAmp, 0);
                      ribbon.scale.lerp(new THREE.Vector3(1,1,1), 0.05);
                      if(ribbon.userData.texture) ribbon.userData.texture.offset.x -= 0.002;
                      mat.emissive.setHex(0x550000);
                      mat.emissiveIntensity = 0.2;
                      mat.opacity = THREE.MathUtils.lerp(mat.opacity, state === AppState.ZOOM ? 0.1 : 0.6, 0.05);
                  }
              }
          };

          const updateStar = (state) => {
              const star = logicDataRef.current.star;
              if (star) {
                  let target = state === AppState.TREE ? star.userData.treePos : star.userData.scatterPos;
                  star.position.lerp(target, 0.05);
                  star.rotation.y += 0.01;
                  if (rainbowStarModeRef.current) {
                      const hue = (timeRef.current * 0.1) % 1;
                      if (star.material) {
                          star.material.emissive.setHSL(hue, 1, 0.5);
                          star.material.emissiveIntensity = 2.0;
                      }
                  }
              }
          };

          const updatePhotos = (state) => {
              photoMeshesRef.current.forEach((group, idx) => {
                  let targetPos, targetScale = 1.0; 
                  if (state === AppState.ZOOM && idx === zoomTargetIndexRef.current) {
                      targetPos = mainGroup.worldToLocal(new THREE.Vector3(0, 0, 80));
                      targetScale = 3.5;
                      group.lookAt(camera.position); 
                  } else if (state === AppState.SCATTER) {
                      targetScale = 2.0; 
                      group.lookAt(camera.position);
                      targetPos = group.userData.scatterPos;
                  } else {
                      targetPos = group.userData.treePos;
                      group.rotation.x = THREE.MathUtils.lerp(group.rotation.x, group.userData.baseRot.x, 0.1);
                      group.rotation.y = group.userData.baseRot.y + timeRef.current * 0.5; 
                      group.rotation.z = THREE.MathUtils.lerp(group.rotation.z, group.userData.baseRot.z, 0.1);
                  }
                  group.position.lerp(targetPos, 0.1);
                  group.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
              });
          };

          const animate = () => {
              requestRef.current = requestAnimationFrame(animate);
              timeRef.current += 0.016;
              
              predictWebcam();
              
              const state = appStateRef.current;
              const group = mainGroup;

              if (isHoldingStarRef.current && !isEpicSequenceRef.current) {
                  if (inputModeRef.current === 'touch' && starHoldStartTimeRef.current > 0) {
                       const holdTime = Date.now() - starHoldStartTimeRef.current;
                       const progress = Math.min(holdTime / 3000, 1.0);
                       setHoldProgress(progress);
                       if (progress >= 1.0 && !hasTriggeredEpicRef.current) {
                          hasTriggeredEpicRef.current = true;
                          isEpicSequenceRef.current = true;
                          epicTimerRef.current = 0;
                          playWeWishYou();
                          setBlessingCount(prev => prev + 1);
                          rainbowStarModeRef.current = true;
                          setHoldProgress(0);
                       }
                  }
              }

              if (isEpicSequenceRef.current) {
                  epicTimerRef.current += 0.016;
                  const t = epicTimerRef.current;
                  if (group.rotation.y > Math.PI) group.rotation.y -= 2 * Math.PI;
                  if (group.rotation.y < -Math.PI) group.rotation.y += 2 * Math.PI;
                  group.rotation.x = THREE.MathUtils.lerp(group.rotation.x, 0, 0.05);
                  group.rotation.y = THREE.MathUtils.lerp(group.rotation.y, 0, 0.05);
                  group.rotation.z = THREE.MathUtils.lerp(group.rotation.z, 0, 0.05);
                  rotationVelocityRef.current = 0;
                  if (t < 3.0) group.scale.setScalar(1.0 + Math.sin(t * Math.PI * 2) * 0.1);
                  else group.scale.setScalar(1.0);
                  if (t > 3.0 && t < 6.0 && Math.random() < 0.1) {
                      const warmColors = [0xFFD700, 0xFFA500, 0xFF4500];
                      const c = warmColors[Math.floor(Math.random()*warmColors.length)];
                      spawnFirework(c, 'snow');
                  }
                  if (t > 18.0) {
                      isEpicSequenceRef.current = false;
                      setAppState(AppState.TREE);
                  }
              }

              if (state !== AppState.ZOOM && interactionRef.current.touches !== 2 && !isGoldModeRef.current && !isEpicSequenceRef.current && (inputModeRef.current === 'touch')) {
                  group.rotation.y += rotationVelocityRef.current;
                  rotationVelocityRef.current *= 0.95; 
                  if (settingsRef.current.rotationEnabled && Math.abs(rotationVelocityRef.current) < 0.0005 && state === AppState.TREE) {
                      group.rotation.y += 0.002;
                  }
              }
              if (shakeIntensityRef.current > 0) {
                  group.position.x = (Math.random() - 0.5) * shakeIntensityRef.current;
                  group.position.y = (Math.random() - 0.5) * shakeIntensityRef.current;
                  shakeIntensityRef.current *= 0.9;
              } else {
                  group.position.set(0,0,0);
              }

              if (interactionRef.current.touches === 4 && (Date.now() - interactionRef.current.startTime) > 500 && Math.random() < 0.1) spawnFirework(undefined, 'normal');

              updateInstancedSystem(logicDataRef.current.gold, group, state, 'gold');
              updateInstancedSystem(logicDataRef.current.silver, group, state, 'silver');
              updateInstancedSystem(logicDataRef.current.gem, group, state, 'gem');
              updateInstancedSystem(logicDataRef.current.emerald, group, state, 'emerald');
              updateDustParticles(state);
              updatePhotos(state);
              updateRibbon(state);
              updateStar(state);
              updateFireworks();

              composer.render();
          };

          animate();

          const onWindowResize = () => {
              if (!containerRef.current || !cameraRef.current || !rendererRef.current) return;
              const width = containerRef.current.clientWidth;
              const height = containerRef.current.clientHeight;
              cameraRef.current.aspect = width / height;
              cameraRef.current.updateProjectionMatrix();
              rendererRef.current.setSize(width, height);
              composer.setSize(width, height);
          };
          window.addEventListener('resize', onWindowResize);

          return () => {
              window.removeEventListener('resize', onWindowResize);
              if (requestRef.current) cancelAnimationFrame(requestRef.current);
              if (containerRef.current && renderer.domElement) containerRef.current.removeChild(renderer.domElement);
              renderer.dispose();
          };
        }, []); 

        const initAudio = () => {
          if (!audioContextRef.current) {
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (audioContextRef.current.state === 'suspended') {
            audioContextRef.current.resume();
          }
        };

        const playBellSound = () => {
          if (!settingsRef.current.soundEnabled) return;
          initAudio();
          const ctx = audioContextRef.current;
          if (!ctx) return;
          const t = ctx.currentTime;
          const partials = [1, 2, 3, 4.2];
          const baseFreq = 880; 
          partials.forEach((partial, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(baseFreq * partial, t);
              gain.gain.setValueAtTime(0, t);
              gain.gain.linearRampToValueAtTime(0.1 / (i + 1), t + 0.02);
              gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.start(t);
              osc.stop(t + 1.5);
          });
        };

        const playJingleBells = () => {
          if (!settingsRef.current.soundEnabled) return;
          initAudio();
          const ctx = audioContextRef.current;
          if (!ctx) return;
          const notes = [
            { f: 329.63, d: 0.2, t: 0 }, { f: 329.63, d: 0.2, t: 0.25 }, { f: 329.63, d: 0.4, t: 0.5 },
            { f: 329.63, d: 0.2, t: 1.0 }, { f: 329.63, d: 0.2, t: 1.25 }, { f: 329.63, d: 0.4, t: 1.5 },
            { f: 329.63, d: 0.2, t: 2.0 }, { f: 392.00, d: 0.2, t: 2.25 }, { f: 261.63, d: 0.2, t: 2.5 }, { f: 293.66, d: 0.2, t: 2.75 }, { f: 329.63, d: 0.8, t: 3.0 }
          ];
          notes.forEach(n => {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = n.f;
            const startTime = ctx.currentTime + n.t;
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, startTime + n.d);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(startTime);
            osc.stop(startTime + n.d);
          });
        };

        const playWeWishYou = () => {
          if (!settingsRef.current.soundEnabled) return;
          initAudio();
          const ctx = audioContextRef.current;
          if (!ctx) return;
          const melody = [
            {f: 261.63, t:0, d:0.4}, {f: 349.23, t:0.4, d:0.4}, {f: 349.23, t:0.8, d:0.2}, {f: 392.00, t:1.0, d:0.2}, {f: 349.23, t:1.2, d:0.2}, {f: 329.63, t:1.4, d:0.2},
            {f: 293.66, t:1.6, d:0.4}, {f: 293.66, t:2.0, d:0.4}, {f: 293.66, t:2.4, d:0.4}, {f: 392.00, t:2.8, d:0.4}, {f: 392.00, t:3.2, d:0.2}, {f: 440.00, t:3.4, d:0.2},
            {f: 392.00, t:3.6, d:0.2}, {f: 349.23, t:3.8, d:0.2}, {f: 329.63, t:4.0, d:0.4}, {f: 261.63, t:4.4, d:0.4}, {f: 261.63, t:4.8, d:0.4},
            {f: 440.00, t:5.2, d:0.4}, {f: 440.00, t:5.6, d:0.2}, {f: 493.88, t:5.8, d:0.2}, {f: 440.00, t:6.0, d:0.2}, {f: 392.00, t:6.2, d:0.2}, {f: 349.23, t:6.4, d:0.4},
            {f: 293.66, t:6.8, d:0.4}, {f: 261.63, t:7.2, d:0.2}, {f: 261.63, t:7.4, d:0.2}, {f: 293.66, t:7.6, d:0.4}, {f: 392.00, t:8.0, d:0.4}, {f: 329.63, t:8.4, d:0.4},
            {f: 349.23, t:8.8, d:1.5}
          ];
          melody.forEach(n => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.type = 'triangle';
              osc.frequency.value = n.f;
              const osc2 = ctx.createOscillator();
              osc2.type = 'triangle';
              osc2.frequency.value = n.f + 1.5;
              osc2.connect(gain);
              gain.gain.setValueAtTime(0, ctx.currentTime + n.t);
              gain.gain.linearRampToValueAtTime(0.2, ctx.currentTime + n.t + 0.1);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + n.t + n.d);
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.start(ctx.currentTime + n.t);
              osc.stop(ctx.currentTime + n.t + n.d);
              osc2.start(ctx.currentTime + n.t);
              osc2.stop(ctx.currentTime + n.t + n.d);
          });
        };

        const addPhotoMesh = (img) => {
          if (!mainGroupRef.current) return;
          const tex = new THREE.Texture(img);
          tex.needsUpdate = true;
          tex.colorSpace = THREE.SRGBColorSpace;
          
          let w = 4, h = 4;
          if(img.width > img.height) h = 4 * (img.height/img.width); 
          else w = 4 * (img.width/img.height);
          
          const photoGeo = new THREE.PlaneGeometry(w, h);
          const photoMat = new THREE.MeshStandardMaterial({ 
              map: tex, 
              side: THREE.DoubleSide,
              roughness: 0.5,
              metalness: 0,
              emissive: 0x000000 
          });
          const photoMesh = new THREE.Mesh(photoGeo, photoMat);
          photoMesh.position.z = 0.06; 
          photoMesh.castShadow = true;
          photoMesh.receiveShadow = true;

          const frameGeo = new THREE.BoxGeometry(w + 0.5, h + 0.8, 0.1);
          const frameMat = new THREE.MeshStandardMaterial({ 
              color: 0xFFFFFF, 
              roughness: 0.4, 
              metalness: 0.1,
              emissive: 0x222222, 
              emissiveIntensity: 0.2
          });
          const frameMesh = new THREE.Mesh(frameGeo, frameMat);
          frameMesh.castShadow = true;
          frameMesh.receiveShadow = true;
          
          const group = new THREE.Group();
          group.add(frameMesh);
          group.add(photoMesh);
          
          const h_pos = (Math.random() - 0.5) * CONFIG.treeHeight;
          const normH = (h_pos + CONFIG.treeHeight/2) / CONFIG.treeHeight;
          const maxR = CONFIG.maxRadius * (1 - normH);
          const r = maxR + 2 + Math.random() * 5; 
          const theta = Math.random() * Math.PI * 2;
          const treePos = new THREE.Vector3(r * Math.cos(theta), h_pos, r * Math.sin(theta));
          const scatterPos = new THREE.Vector3(r * Math.sin(Math.acos(2 * Math.random() - 1)) * Math.cos(2 * Math.PI * Math.random()), r * Math.sin(Math.acos(2 * Math.random() - 1)) * Math.sin(2 * Math.PI * Math.random()), r * Math.cos(Math.acos(2 * Math.random() - 1)));

          group.lookAt(new THREE.Vector3(0, h_pos, 0)); 
          const baseRot = group.rotation.clone();

          group.userData = { treePos, scatterPos, baseRot, isPhoto: true };
          group.position.copy(treePos);
          
          photoMeshesRef.current.push(group);
          mainGroupRef.current.add(group);
        };

        const handleTouch = (e, type) => {
            if (inputModeRef.current === 'camera') return;

            initAudio();
            
            const isTouch = 'touches' in e;
            const touches = isTouch ? e.touches : [];
            const touchCount = isTouch ? touches.length : (e.buttons === 1 ? 1 : 0);
            
            interactionRef.current.touches = touchCount;

            if (type === 'start') {
                interactionRef.current.startTime = Date.now();
                const positions = [];
                if (isTouch) {
                    for(let i=0; i<touches.length; i++) positions.push({x: touches[i].clientX, y: touches[i].clientY});
                } else {
                    positions.push({x: e.clientX, y: e.clientY});
                }
                interactionRef.current.startPositions = positions;
                
                if (touchCount === 2) {
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    interactionRef.current.lastDistance = Math.sqrt(dx*dx + dy*dy);
                    interactionRef.current.lastAngle = Math.atan2(dy, dx);
                }
                rotationVelocityRef.current = 0;

                if (touchCount === 1) {
                    const cx = positions[0].x;
                    const cy = positions[0].y;
                    if (containerRef.current && cameraRef.current) {
                        const rect = containerRef.current.getBoundingClientRect();
                        const x = ((cx - rect.left) / rect.width) * 2 - 1;
                        const y = -((cy - rect.top) / rect.height) * 2 + 1;
                        raycasterRef.current.setFromCamera(new THREE.Vector2(x,y), cameraRef.current);
                        
                        if (logicDataRef.current.star) {
                            const intersects = raycasterRef.current.intersectObject(logicDataRef.current.star);
                            if (intersects.length > 0) {
                                isHoldingStarRef.current = true;
                                starHoldStartTimeRef.current = Date.now();
                                setTouchPos({x: cx, y: cy});
                            }
                        }
                    }
                }
            }

            if (type === 'move') {
                if (touchCount === 1) {
                    const cx = isTouch ? touches[0].clientX : e.clientX;
                    const cy = isTouch ? touches[0].clientY : e.clientY;
                    
                    if (isHoldingStarRef.current) {
                         setTouchPos({x: cx, y: cy});
                    }

                    if (containerRef.current && cameraRef.current) {
                      const rect = containerRef.current.getBoundingClientRect();
                      const x = ((cx - rect.left) / rect.width) * 2 - 1;
                      const y = -((cy - rect.top) / rect.height) * 2 + 1;
                      raycasterRef.current.setFromCamera(new THREE.Vector2(x, y), cameraRef.current);
                      
                      const intersection = new THREE.Vector3();
                      raycasterRef.current.ray.intersectPlane(planeRef.current, intersection);
                      repulsionPointRef.current = intersection;
                    }
                } else if (touchCount === 2 && isTouch) {
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx);
                    
                    const dDist = dist - interactionRef.current.lastDistance;
                    
                    let dAngle = angle - interactionRef.current.lastAngle;
                    if (dAngle > Math.PI) dAngle -= 2 * Math.PI;
                    else if (dAngle < -Math.PI) dAngle += 2 * Math.PI;
                    
                    if (cameraRef.current) {
                        cameraRef.current.position.z -= dDist * 0.15;
                        cameraRef.current.position.z = Math.max(20, Math.min(200, cameraRef.current.position.z));
                    }
                    
                    if (mainGroupRef.current) {
                        mainGroupRef.current.rotation.y += dAngle * 2.0; 
                        rotationVelocityRef.current = dAngle * 0.5;
                    }

                    interactionRef.current.lastDistance = dist;
                    interactionRef.current.lastAngle = angle;
                }
            }

            if (type === 'end') {
                repulsionPointRef.current = null;
                isHoldingStarRef.current = false;
                setHoldProgress(0);

                if (Date.now() - interactionRef.current.startTime < 300) {
                   const lastCount = interactionRef.current.startPositions.length;
                   
                   if (lastCount === 1) {
                       const now = Date.now();
                       if (now - interactionRef.current.lastTapTime < 300) {
                           shakeIntensityRef.current = 5.0;
                       } else {
                           playBellSound(); 
                           const pos = interactionRef.current.startPositions[0];
                           handlePhotoClick(pos.x, pos.y);
                       }
                       interactionRef.current.lastTapTime = now;
                   } else if (lastCount === 2) {
                       setAppState(prev => prev === AppState.TREE ? AppState.SCATTER : AppState.TREE);
                   }
                }
                if (touchCount === 5) {
                   isGoldModeRef.current = true;
                   goldModeTimerRef.current = 8.0; 
                   playJingleBells();
                }
            }
        };

        const handlePhotoClick = (cx, cy) => {
            if (!containerRef.current || !cameraRef.current || !mainGroupRef.current) return;
            const rect = containerRef.current.getBoundingClientRect();
            const x = ((cx - rect.left) / rect.width) * 2 - 1;
            const y = -((cy - rect.top) / rect.height) * 2 + 1;
            raycasterRef.current.setFromCamera(new THREE.Vector2(x,y), cameraRef.current);
            const intersects = raycasterRef.current.intersectObjects(photoMeshesRef.current, true);
            if (intersects.length > 0) {
                let targetObj = intersects[0].object;
                while(targetObj.parent && targetObj.parent !== mainGroupRef.current) targetObj = targetObj.parent;
                const index = photoMeshesRef.current.indexOf(targetObj);
                if (index !== -1) {
                    zoomTargetIndexRef.current = index;
                    setAppState(AppState.ZOOM);
                }
            }
        };

        return (
          <div 
              ref={containerRef} 
              className="w-full h-full cursor-pointer"
              onMouseDown={(e) => handleTouch(e, 'start')}
              onMouseMove={(e) => handleTouch(e, 'move')}
              onMouseUp={(e) => handleTouch(e, 'end')}
              onMouseLeave={(e) => handleTouch(e, 'end')}
              onTouchStart={(e) => handleTouch(e, 'start')}
              onTouchMove={(e) => handleTouch(e, 'move')}
              onTouchEnd={(e) => handleTouch(e, 'end')}
          />
        );
      };

      // --- App.tsx ---
      const App = () => {
        const [appState, setAppState] = useState(AppState.TREE);
        const [statusText, setStatusText] = useState("ç³»ç»Ÿåˆå§‹åŒ–...");
        const [uploadedImages, setUploadedImages] = useState([]);
        const [settings, setSettings] = useState({
          soundEnabled: true,
          rotationEnabled: true,
          ribbonVisible: true
        });
        const [inputMode, setInputMode] = useState('touch');
        const [auroraActive, setAuroraActive] = useState(false);
        const [blessingCount, setBlessingCount] = useState(0);
        const [holdProgress, setHoldProgress] = useState(0);
        const [touchPos, setTouchPos] = useState({ x: 0, y: 0 });
        const videoRef = useRef(null);

        const handleFileUpload = useCallback((files) => {
          if (!files) return;
          Array.from(files).forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
              if (e.target?.result) {
                const img = new Image();
                img.src = e.target.result;
                img.onload = () => {
                  setUploadedImages(prev => [...prev, img]);
                };
              }
            };
            reader.readAsDataURL(file);
          });
        }, []);

        return (
          <div className="fixed inset-0 w-full h-[100dvh] bg-black overflow-hidden select-none touch-none">
            {/* Aurora Background Layer */}
            <div 
              className={`absolute inset-0 z-0 transition-opacity duration-1000 ease-in-out pointer-events-none
                bg-gradient-to-t from-black via-purple-900/40 to-green-900/30
                ${auroraActive ? 'opacity-100' : 'opacity-0'}
              `}
            >
              <div className="absolute inset-0 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] opacity-20 brightness-200 contrast-200"></div>
              <div className={`absolute top-0 left-0 w-full h-full mix-blend-screen opacity-50 ${auroraActive ? 'animate-pulse' : ''}`}>
                 <div className="absolute top-[-50%] left-[-20%] w-[150%] h-[150%] bg-gradient-to-r from-transparent via-green-500/20 to-transparent rotate-12 blur-3xl animate-[spin_20s_linear_infinite]"></div>
                 <div className="absolute top-[-50%] right-[-20%] w-[150%] h-[150%] bg-gradient-to-l from-transparent via-purple-500/20 to-transparent -rotate-12 blur-3xl animate-[spin_15s_linear_infinite_reverse]"></div>
              </div>
            </div>

            {/* 3D Scene Layer */}
            <div className="relative z-10 w-full h-full">
              <JewelTreeScene 
                appState={appState} 
                setAppState={setAppState}
                setStatusText={setStatusText}
                uploadedImages={uploadedImages}
                setAuroraActive={setAuroraActive}
                settings={settings}
                setBlessingCount={setBlessingCount}
                setHoldProgress={setHoldProgress}
                setTouchPos={setTouchPos}
                inputMode={inputMode}
                videoRef={videoRef}
              />
            </div>

            {/* UI Overlay Layer */}
            <div className="relative z-20 pointer-events-none">
              <UIOverlay 
                statusText={statusText}
                onFileUpload={handleFileUpload}
                appState={appState}
                setAppState={setAppState}
                settings={settings}
                setSettings={setSettings}
                blessingCount={blessingCount}
                holdProgress={holdProgress}
                touchPos={touchPos}
                inputMode={inputMode}
                setInputMode={setInputMode}
                videoRef={videoRef}
              />
            </div>
          </div>
        );
      }

      // --- index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>